API Review

Robert Steilberg | rhs16
Grayson Wise | gkw

#Part 1

1. I intend for the game controller.engine and the game controller.editor to be specifically flexible. The game controller.engine in particular should be flexible since it must be able to open a gamefile of any kind and then subsequently run it. As long as the gamefile corresponds to a format accepted by the controller.engine (i.e. a gamefile created with the controller.editor), the gamefile should be accepted. The controller.editor is also intended to be flexible because it will allow for the creation of multiple kinds of RPG games. For example, it will be possible to create games based off of Pokemon, Evoland, Dragon Warrior, et cetera with the single game controller.engine. The GameSaver and GameOpener classes will also be flexible since they should be able to save and open a game of any time, either for editing or playing.

2. Our API design encapsulates much of the basic gameplay that defines how each game functions. For example, NPC settings, model.interactions, battles, and winning conditions are all encapsulated. GameSaver and GameOpener are each encapsulating the design details associated with XML serialization; they will be used throughout game building and playing to open or save gamefiles. The Grid class will encapsulate most of the functionality associated with building RPG stages, since all of our RPG games will be model.grid-based. Thus, we can encapsulate functionality like adding or removing ui.scenes.controller.editor.objects to or from the overworld within this class.

3. My role is generally front end, and links to the back end when the created game is saved or opened. For example, after a overworld is created, it will be serialized and saved so that the back end can then interpret and run it. Additionally, gameplay model.interactions (i.e. battles, NPC settings, et cetera) will be handled through the back end, which is where my role ties into the back end. I must ensure that gameplay settings and serialization are each implemented in a way that allows the back end to tie into this functionality. The game controller.engine will be especially challenging since the back end will need to run the project, yet changes must be pushed to the front end so that the user can perceive and react to them.

4. There are lots of error cases that must be handled in the front end that are associated with building games. For example, if the user attempts to place blocks on the model.grid that conflict with other blocks, the front end must recognize this, reject the changes, and then prompt the user as to why overlaid blocks are not allowed. Furthermore, there are more sophisticated error cases associated with detecting gameplay. For example, if a user creates a game without a winning case, it may be a good idea to recognize this and then prompt the user to add a winning case so that the game is playable. Another error case that will need to be handled is if the user tries to play a gamefile that is not a valid gamefile type or that is corrupted. More sophisticated error detection may need to be handled by the back end but the front end game controller.engine file opener may be able to handle some initial trivial cases.

5. I believe our API is well designed in terms of how we separate the controller.editor and controller.engine. We intend for the controller.editor and controller.engine to be completely separate. For example, the controller.editor should be able to create games and open them for further editing at will, and the controller.engine need only be able to open any valid gamefile and run it. However, it may be useful to allow an instance of the controller.engine to run within the controller.editor for testing, which will not be difficult to implement since the controller.engine is completely separate from the controller.editor. Furthermore, I think that encapsulating gamefile saving and opening is "good" design in the sense that it is encapsulated and separate. Lastly, I think that encapsulating the functionality associated with the gameplay components (i.e. defining battles, defining NPCs, defining model.interactions) is good design because it will be easy to add more functionality implementations since each implementation is encapsulated. These examples are all "good" design in the sense that they are separate and easily extensible

#Part 2

1. I am most excited to work on the controller.editor component of our game authoring controller.engine because I want to craft a design that is intuitive and easy to follow. My goal is to build an controller.editor that is simple and easy to use for any user, yet allows the user to build powerful games.

2. I am most worried about working on the controller.engine component of our game authoring controller.engine. I am worried that it will be difficult to build an controller.engine that can read and execute any gamefile created with the controller.editor, and I am also still unsure about how the controller.engine will tie into the front end. Specifically, I don't yet understand how the back end will read in serialized XML files and then somehow convert those files into something that the front end can interpret and run as a fully functional game. I am also significantly worried about serializing the model.interactions that the user defines in the controller.editor.

3. I have just finished implementing the main menu; this weekend, I hope to implement the functionality for the game controller.editor. Ideally, by the end of the weekend, our VOOGA will have a completely functional game controller.editor that can successfully save games that the user creates.

4. I think our use cases are appropriate for what our game controller.editor and controller.engine need to do. There is a significant number of editing details that our controller.editor will have to account for, and I feel that we have described a wide spread of these potential functional components through our use cases. The majority of our use cases (> 30 of them) are related to the controller.editor. We may need more use cases specifically related to catching errors or the game controller.engine.

5. We have use cases that cover functionality during which errors may be thrown, but we need more use cases that specifically deal with cases in which an error will always be thrown. For example, some good additional use cases would be handiling opening a corrupted gamefile, opening a non-gamefile file, creating a game without a winnable state, et cetera.